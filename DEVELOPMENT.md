### Week 1

We created classes representing graphs, vertices, and edges. In the graph class, the constructor takes in an airport data file (for the vertices) and a routes data file (for the edges). The constructor parses these two files, discards any problematic/invalid vertices and edges, and stores the valid vertices and edges in unordered maps. In addition to the vertices map and the edges map, the graph class also stores an unordered map that maps each vertex to a vector of all that vertex's neighbors (the adjacency list). The graph, vertex, and edge class implementations are in `graph.h` and `graph.cpp`. We used these classes to parse our main data files (`airports.dat` and `routes.dat`) into a graph representation. In addition, we created some basic test cases to ensure that a simple graph could be created properly. We also tested that the graph creation correctly handled invalid inputs.

### Week 2

We implemented a BFS traversal function within our graph class. The traversal explores all connected components by iterating over all vertices in the graph and running a BFS traversal on any unvisited vertices (via a helper function that takes a starting vertex as an argument). The function returns a vector of vertex keys (airport codes) in the order visited by the BFS traversal. We also implemented a version that takes in the start of the BFS as a parameter. We also began implementing a function that returns the shortest path between two airports (or specifies that no such path exists) based on the distances between airports (calculated by the specified coordinates) using Dijkstra's algorithm. This function takes in the two endpoints and returns a string representing the shortest path and the distance corresponding to the shortest path. We added test cases to check that our function was behaving correctly on small graphs (correctly finding the shortest path or detecting that no path existed).

### Week 3

We implemented a demo within the main.cpp file that allows the user to interact with the three algorithms implemented: BFS, Dijkstras, and PageRank. Our demo properly handles cases where the user enters an invalid airport code or an invalid command by letting the user know that the airport is not recognized, or prompting them to re-enter a valid command. We added test cases to ensure that our implementation of Dijkstra's algorithm would choose a multiple-node path over a direct path, if the edge weights are set so that the direct path is longer than the multiple-node path. We added test cases to ensure that when PageRank is called on a circular connected graph where each vertex has one outgoing edge and one incoming edge, the ranks of all the vertices are the same and all the ranks add up to 1.0. We also added a test case to confirm that when PageRank is called on a small unconnected graph containing vertices with no outgoing edges, that the algorithm still assigns a rank to these vertices. 