### Week 1

We created classes representing graphs, vertices, and edges. In the graph class, the constructor takes in an airport data file (for the vertices) and a routes data file (for the edges). The constructor parses these two files, discards any problematic/invalid vertices and edges, and stores the valid vertices and edges in unordered maps. In addition to the vertices map and the edges map, the graph class also stores an unordered map that maps each vertex to a vector of all that vertex's neighbors (the adjacency list). The graph, vertex, and edge class implementations are in `graph.h` and `graph.cpp`. We used these classes to parse our main data files (`airports.dat` and `routes.dat`) into a graph representation. In addition, we created some basic test cases to ensure that a simple graph could be created properly. We also tested that the graph creation correctly handled invalid inputs.

### Week 2

We implemented a BFS traversal function within our graph class. The traversal explores all connected components by iterating over all vertices in the graph and running a BFS traversal on any unvisited vertices (via a helper function that takes a starting vertex as an argument). The function returns a vector of vertex keys (airport codes) in the order visited by the BFS traversal. We also implemented a version that takes in the start of the BFS as a parameter. We also began implementing a function that returns the shortest path between two airports (or specifies that no such path exists) based on the distances between airports (calculated by the specified coordinates) using Dijkstra's algorithm. This function takes in the two endpoints and returns a string representing the shortest path and the distance corresponding to the shortest path. We added test cases to check that our function was behaving correctly on small graphs (correctly finding the shortest path or detecting that no path existed).